---
layout: post
section-type: post
title: "[ 작성중 ] sorting algorithm (with. python3)"
categories: Computer_Science
tags: [ 'computer_science' ]
comments: true
---

# 알고리즘을 시각화 해서 보여주는 tool
https://visualgo.net/en/sorting

# 정렬 알고리즘 종류와 특징
<img src="images/2018-10-31-sort/sort_algorithm.png" />



# Selection sort
> 평균 및 최악 실행 시간: O(N^2)
> 메모리: O(1)

탐색을 하면서 찾은 작은 원소를 배열 맨 앞으로 보내는 것이다.
계속 차례대로 다음 작은 애를 찾아서 앞으로 보낸다.

# merge sort
> 평균 및 최악 실행 시간: O(NlogN)
> 메모리: O(1)

n개를 n/2, n/2로 나눈다.
왼쪽 오른쪽 각자 정렬하고 결과를 하나로 합친다.

# bubble sort
> 평균 및 최악 실행 시간: O(N^2)
> 메모리: O(1)

버블 정렬은 배열의 첫 원소부터 순차적으로 진행하며, 현재 원소가 그 다음 원소의 값보다 크면 두 원소를 바꾸는 작업을 반복하나.
이런식으로 배열을 계속 살펴보면서 완전히 정렬된 상태가 될 때까지 반복한다.

n은 a의 길이

``` python
for i in range(1, n):
    change = False
    for j in range(1, n-1):
        if a[j] > a[j+1]:
            change = True
            a[j+1], a[j] = a[j], a[j+1]
```


# quick sort
> O(NlogN)

재귀를 이용한 분할정복 알고리즘
특정 pivot이라는 기준을 새워,
pivot 기준 작으면 왼쪽 크면 오른쪽
퀵 소트의 최악의 경우는 O(N^2)

1. 피봇 정하고
2. 기준 작으면 왼, 크면 오
3. 정렬 될때까지 왼,오 나누어 분할

# time sort
> O(NlogN)

python에서 쓰는 sort는 time sort이다.
quick sort를 안쓰는 이유는 정렬 됬을 시 time complexity가 높을 가능성 때문이다.
그래서 big O의 성능이 평균적으로 좋은 O(NlogN)을 사용한다.
(작성중)https://joosjuliet.github.io/time_sort/
*작성중이지만 일단 따로 포스팅을 해놨다*


---
참고자료

http://vcdstr.knou.ac.kr/vcdstr/vcd/e_s/Y/234525/M3452512104004/sum01.htm
