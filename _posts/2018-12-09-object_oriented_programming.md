---
layout: post
section-type: post
title: "[object_oriented_programming 0편] 객체 지향이란?"
category: Computer_Science
tags: [ 'object_oriented_programming', '글또2기', 'computer_science' ]
comments: true
---

# 이글을 쓴 이유
object_oriented_programming 에 요즘 관심이 있어서 계속 공부를 하고 있는데 그러다가 개념 정리를 좀 더 깔끔히 하고 싶어져서 글을 썼습니다.


# 객체란
> 객체는 일상생활에 있는 것을 코드로 옮겨서 컴퓨터에 저장 해 논 것

객체라는 말이 매우 철학적이고 소프트웨어 공학적으로 보이지만 그건 단지 상태 + 행위의 집합일 뿐입니다.
현실 세계의 물체를 객체의 상태와 행위를 추려내 설계도로 만들어서 논 것입니다.
여기서 속성은 상태고, 메서드는 행위입니다.

## 클래스
>객체를 만들기 위한 설계도

class를 통해 특정 기능별 상태와 행위를 모아서 관리를 할 수 있습니다.
구조체(변수를 관리 하는 것) + method


# 객체지향이란

구현동화 ver
> 프로그램의 부품화

전문가 ver
>프로그램을 수많은 '객체'라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식

객체지향은 절차지향은 기능 별로 코드를 분리하고자 하는 욕망에서 태어난 원리입니다. 그렇게 되면 재사용성과 의미 파악이 좋아지기 때문입니다.


# 객체 지향의 주 특징

#### 1. 자료 추상화
>불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것

표현과 연산을 캡슐화해 접근 제어를 통해서 정보를 은닉하는 것이다.

#### 2. 상속
> 새로운 클래스가 기존의 클래스의 자료와 연산을 이용할 수 있게 하는 기능

상속을 통해서 기존의 클래스를 상속받은 하위 클래스를 이용해 프로그램의 요구에 맞추어 클래스를 수정할 수 있고 클래스 간의 종속 관계를 형성함으로써 객체를 조직화할 수 있다.

#### 3. 다형성
> 어떤 한 요소에 여러 개념을 넣어 놓는 것

일반적으로 오버라이딩이나 오버로딩을 의미한다. 다형 개념을 통해서 프로그램 안의 객체 간의 관계를 조직적으로 나타낼 수 있다.

#### 4. 동적 바인딩
> 동적으로 값을 바꾸거나 넣는 것

동적 바인딩은 실행 시간 중에 일어나거나 실행 과정에서 변경될 수 있는 바인딩으로 컴파일 시간에 완료되어 변화하지 않는 정적 바인딩과 대비되는 개념이다. 동적 바인딩은 프로그램의 한 개체나 기호를 실행 과정에 여러 속성이나 연산에 바인딩함으로써 다형 개념을 실현한다.


# 객체 지향의 장점

S/W의 질을 향상하기 위해 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향해야 하는데, OOP의 경우 클래스에 하나의 문제 해결을 위한 데이터를 모아 놓은 데이터형을 사용함으로써 응집력을 강화하고, 클래스간에 독립적으로 디자인함으로써 결합력을 약하게 할 수 있다.

그럼으로 재사용성이 좋아서 일어나는 부수적 효과는

1. 새코드를 작성시 기존 코드를 이용하기에 코드의 재사용성이 높습니다.
2. 각 코드에 관계를 맺어주었고 재사용성을 높여주었기에 관리가 쉽습니다.
3. 제어자와 메서드를 이용해 데이터가 보호받고 있으며, 코드 중복을 제거해 코드에 신뢰도가 높습니다.


# 객체 지향의 단점
- 상속은 개념은 면밀한 자료 분석, 개발시간 단축, 좀더 정확한 코딩을 보증하지만 개발 커브가 높다. 특히, 다중 상속이 되면 순환 상속(자식이 부모의 조상이 되는 상황)이 될 수 있는 위험도 있다. (해결책으로 상속보다 프로시져를 사용하는 법도 있다.)

- 계속 객체를 만들 때 마다 그 속에 있는 변수를 만들 기 때문에 운영체제에서 메모리 관리 하기가 어렵다.


# SOLID (객체 지향 설계)

## S - SRP(Single responsibility principle) 단일 책임 원칙
> 모든 클래스는 단 하나의 역할만 가진다.

## O - OCP(Open Closed Principle) 개방 - 폐쇄 원칙
> 확장에 개방, 수정에는 폐쇄.

## L - LSP(Liskov Substitusion Principle) 리스코프 치환 법칙
> 부모클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다.

자식 클래스는 언제나 자신의 부모클래스를 교체할 수 있다는 원칙이다.
(언제나 업 캐스팅 가능)

## I - ISP(Interface Segregation Principle) 인터페이스 분리 원칙
> 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙.

자신이 사용하지 않는 기능(인터페이스)에는 영향을 받지 말아야 한다.

## D - DIP(Dependency Inversion Principle) 의존성 역전 법칙
> 상위클래스는 하위클래스에 의존해서는 안된다는 법칙.

하위클래스가 상위클래스에 의존을 해야지 상위클래스가 하위클래스에 의존하면 안된다.

# 참고 하면 좋은 자료

객체 지향을 좀 더 코드와 함께 다루는 코드는 다른 글에 쓰여있습니다.[with python]
https://joosjuliet.github.io/object_oriented_programming_1_with_python/
https://joosjuliet.github.io/object_oriented_programming_2_with_python/
https://joosjuliet.github.io/object_oriented_programming_3_with_python/


---

참고자료

객체 지향 관련된 내용 참고한 곳
https://wikidocs.net/22335
https://m.blog.naver.com/wpgud6/221258231532

solid 원칙 참고한 곳:
https://wkdtjsgur100.github.io/solid-principle/
https://ko.wikipedia.org/wiki/SOLID_(객체_지향_설계)
