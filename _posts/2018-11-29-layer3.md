---
layout: post
section-type: post
title: "[Network 1일차] ip란 무엇인가 (layer 3)"
category: Computer_Science
tags: [ 'computer_science', '글또1기', 'network' ]
comments: true
---

# IP / Internet Addressing

이제 IP에 대해서 조금 더 자세하게 알아보자. IP는 계층 3에서 모든 호스트들이 통신을 가능하도록 주소를 동일하고 unique 하게 해주는 프로토콜인데, 종류에는 IPv4, IPv6가 있고, 현재 IP주소 체계는 IPv4를 사용한다.  

## IPv4

- 32bit로 표현되는 주소체계. xxx.xxx.xxx.xxx 형태로 표현되며, 2^32, 약 40억개의 서로 다른 주소를 표현할 수 있다.
- 우리가 친구네 집을 놀러갔을 때, 그 친구가 사는 동네와 아파트 동을 먼저 찾은 뒤 호를 찾는 것처럼, 네트워크에서도 B호스트에 연결된 네트워크를 먼저 찾은 뒤 호스트를 찾아가야한다.
- 때문에 IP주소는 prefix 부분과 suffix 부분으로 나뉘어진다. prefix는 물리적인 네트워크를 표현하며 suffix는 특정 호스트를 표현한다.
- 아래 그림과 같이 IP주소를 네트워크 크기에 따라 Class를 나눌 수 있다. Class D는 특정 그룹이 데이터를 받도록 하는 것(multicast)을 위한 클래스이다.
![IP주소](https://joosjuliet.github.io/assets/img/1.png)

suffix부분이 크다는 것은 host가 많다는 얘기로 network가 크다는 의미이다.
D->multicast라는 특수한 경우에 쓴다.

- 네트워크의 크기는 Class A~E 이외에도 더욱 다양한 방식으로 쪼개질 수도 있는데, 이를 효율적으로 하기 위해 두 가지 방법을 사용한다.
    - Subnet: Sub+Net, 즉 큰 네트워크를 잘라서 여러 회사가 나눠쓰는 개념. 큰 네트워크를 서브로 나눠서 쓰자 [개념]
    - CIDR(Classless Inter Domain Routing) notation: [표기법] 192.173.242.33/26 처럼 IP주소 뒤에 /n을 붙여서 prefix가 몇 비트를 차지하는 지 표기하는 방법을 말한다.

서브넷으로 나눈다음 CIDR로 표기할 수 있따. 즉 두개를 혼합해서 사용할 수 있다.

- 두 네트워크에 하나의 호스트가 연결되어 있으면 그 호스트는 IP 주소를 두개를 할당 받아야 하고, 이를 multi-homed host 라고 한다.
- multi-homed host에는 router가 있다.

- IP에는 특정한 목적으로 사용되는 특별한 IP 주소가 있다.
![IP주소](https://joosjuliet.github.io/assets/img/2.png)

bootstrap은 0.0.0.0을 써야하는데 ip통신을 하려면 주소가 필요한데 아직 할당 받기 전이어서 0.0.0.0이다.
3번째는 특정 net에 보내는 것

> 초기 PC는 DHCP 라는 프로토콜을 사용해 DHCP 서버에서 IP를 발급받게 됩니다. 하지만 서버에서 DHCP서버에 요청하기 위해서는 초기 IP가 필요한데, 0.0.0.0이 그 때 쓰입니다.

## IP Datagram

레이어 3에서 이동하는 패킷을 Datagram이라 한다. Datagram 역시 Header와 Payload로 구성된다.

### Datagram Header
![header](https://joosjuliet.github.io/assets/img/3.png)

Datagram Header를 자세히 살펴보자. 다음 그림과 같이 Datagram Header는 구성된다.

- VERS: 현재 IP의 버전이 적혀있다(IPv4를 썼으니 아마 0100이 적혀있을 것)
- H.LEN: 헤더의 길이
- SERVICE TYPE: 실제 통신되는 서비스의 질(퀄리티)에 대한 정보.(실제로는 거의 안쓴다고 한다.)
- TOTAL LENGTH : Payload까지 포함한 전체 길이
- IDENTIFICATION: 데이터 그램의 고유 번호. 자른 데이터를 합칠때 여기 적혀있는 ID를 활용해서 합친다.
- FRAGMENT OFFSET: 자른 애들의 순서를 나타내기 위해서 사용됨.
- FLAGS
    - M이면 More segment, 0이면 내가 마지막 세그먼트라는 것을 표시
    - D이면 Do not 자르지말라는 뜻이다.
- TIME TO LIVE: 데이터 보냈는데 라우터가 잘못돼서 하루 종일 헤메는 것을 막기 위함. 실제로 여기에 저장된 값에서 라우터를 만나면 1을 빼주고, 0이 되면 패킷을 버린다.
- TYPE(Protocol Identifier): 계층 2에서 이 패킷의 프로토콜을 표시
ICMP -> 1,  IGMP -> 2,  TCP -> 6,  EGP -> 8,  UDP -> 17,  OSPF -> 89
- HEADER CHECKSUM: 오류를 검출하기 위한 CHECKSUM

datagrame header 의 크기는 option제외하고니까 20byte

전체적인 경로를 찾는 것이 routing
포워딩은 이 네트워크 찾으려면 이 next hop으로 가야해 라고 눈 앞의 빠른 길 알려주는 것이 datagram forwarding

# Datagram Forwarding

서로 다른 네트워크에 있는 A, B호스트가 통신한다고 가정하자. 이를 위해 IP로 각각의 호스트에 고유의 주소를 붙여 주었다면, 이제 A호스트에서 보낸 패킷이 B호스트를 어떻게 찾아가느냐가 중요하다.   
각각의 네트워크들 사이에는 통신을 위한 라우터(Router)가 있는데(이전에 언급 했었다), 이 라우터가 패킷을 포워딩(Forwarding) 시켜준다. 포워딩이란 정확히 얘기해서 **패킷을 받았을 때 다음으로 이동해야할 라우터가 어디인가?를 결정하는 것을 포워딩이라 한다.** 그리고 Datagram이 이동하기 때문에 이를 Datagram Forwarding이라 한다.  

> Note: Layer 2에서는 패킷을 프레임(frame)이라 부르고, Layer 3에서는 데이터그램(Datagram)이라 한다.

## 라우터는 어떻게 데이터그램을 포워딩 할까?

- 라우터는 목적지로 갈 수 있는 수많은 길들 중에서 어떻게 가장 최적의 길을 결정하고 패킷을 보낼까?
- 라우터는 Forwarding Table을 보고, 패킷이 이동할 다음 라우터를 결정한다.
- Forwarding Table의 구성
    1. Destination Network Address: 목적지의 네트워크 주소가 적혀있다.
    2. Mask: Destination Network Address의 Address Mask 주소가 적혀있다. destination 네트워크 크기가 이래요 하는 것.
    3. Next Hop: 다음으로 이동할 라우터 또는 경로의 주소가 적혀있다.
- 패킷의 Next Hop을 결정할 때는 다음과 같은 연산을 수행해 결정한다.
``` c
if( (Mask & D) == Destination Network Address ) forwarding to Next Hop
```
- 두 개의 결과가 나올 수도 있는데, 그 결과 중 긴 prefix를 취하도록 한다.
- 마지막 라우터는 데이터그램을 forwarding 하는 것이 아니라 deliver를 수행한다.

> Forwarding Table은 Routing 방법을 통해 초기화 되는데,

## IP Encapsulation

데이터그램의 포맷을 Frame으로 만드는 것을 캡슐화(Encapsulation)이라 한다. 실제 물리적인 네트워크는 데이터 그램을 이해를 못하기 때문에, 각 네트워크를 이동할 때마다 네트워크가 이해할 수 있게 데이터 그램에 Frame Header가 붙는다. 결국, 아래와 같이 Frame Header를 뗐다 붙였다하는 방식으로 통신한다.
![ip_encapsulation](https://joosjuliet.github.io/assets/img/4.png)

최종적으로 목적지 호스트는 데이터 그램을 받게 된다.

네트워크 마다
1. 주소 체제가 다르거나
2. 주고 받는 패킷의 형태가 달라서
통신이 불가능하다.

# 인터넷 생긴이유
세계적 자유롭게 통신을 할 수 있게 하기 위해서 만든 것이 인터넷이다.
각 네트워크 별 주소체계, 패킷도 다를 수 있다.
그래서 1에서 2 네트워크로 보낼 때 규약이 다르면 안되니 layer3에서 모든 네트워크 규칙을 정해서 얘기할 수 있게 하는 것
계층이 가진 철학 -> 어떤 end point든 다 동일하게 취급한다.


Internet은 하나의 네트워크라고 가정은 했지만, 실제로 존재는 하지 않고 라우터와 작은 네트워크들로 구성된다. 그래서 virtual network라고도 부른다.



# 그래서 router라는 개념이 생김
인터넷은 서로 규약 다른 네트워크를 연결하는 걸 만들어서 네트워크 다르더라도 통신 도와줄 수 있게 만들어주자
그래서 만들어진게 router

# router 일
- 패킷 포워딩
  1. 어느 네트워크를 거쳐야 빨리 도착하는 지를 알려주는 게 라우터 일
- 형식 변환
  2. 형식 변환해서 알려준다.(호환)

## 패킷 포워딩
## 형식 변환
모든 네트워크가 쓸 수 있는 프로토콜을 정하자. -> ip
모두가 공통적으로 쓰는 것 -> ip

*host 응용프로그램을 수행하는 컴퓨터*

# 맥주소 vs ip
(고유한)맥주소는(기계의 고유주소, 주민등록번호) datalink에서 부여받는 것,
왜 유일한건데 ip를 쓰지 왜 두개다 유일하지?(이건 그냥 주소)

#ip 는
32bit로 표현된 주소체계
32를 4로 나눠서 8bit * 4
즉 xxx.xxx.xxx.xxx
왼쪽에서 부터 3번째까지가 네트워크 주소다 하면 그게 네트워크 크기인것이다.
그리고 나머지는 다 호스트이다.

예를 들어 192.193.192.1 이면, 가장 첫번째부터 32-8 =24번째 비트까지가 네트워크 주소고, 나머지가 호스트 주소다 라고 하면은
192.19,,...../




NAT가 42억 그거다.
서울 강남구 테헤란로 507 위워크 6층 108호
서브넷 마스크
=> A,B,C class나눈 이유
end to end 통신이 결국에 패킷 보낼 때 하나의 컴퓨터에서 다음 컴퓨터로 보내는 거잖아
보내기 위해서는 ip주소를 보고 가는 건데
동이랑 호를 알면 더 빨리 찾겠지

그러니까
prefix | suffix 사진 첨부
두개로 나눠서 동과 호를 분리
클래스 다섯개로 나뉘는데 a를 봐 suffix가 많지. 호스트 표현할 게 많지 그럼 더 큰 네트워크겠지
d,e는 멀티케스트 용





그래서 그런식으로 구성하기 위해서 네트워크라는 개념을 만들었고,
네트워크 구분하는 기준이, class로 필터링을 해서 a class 에 해당하는 크기의 네트워크
b,c class 크기 네트워크

a,b,c 클래스로 구분하기에는 네트워크 크기가 다양해. 그래서 3개로만 나누느 것이 아니라 네트워크 크기를 그냥
ip주소 전체르 보면 그건 두개로 나뉘어진다.
network, host주소로 나눠진다.

이건 그냥 예시겠지 더 다양할테지

# 그걸 효율화시키기 위해서
- Subnet
- CIDR
  - network가 어디서 부터 어디까지인가 인가를 지정해 놓는 것을 써놓는다. 그게 바로 cibr이라고 ip주소 끝나고 /하고 비트 수 적혀있따.
    비트 수가 네트워크 차지하는 비트 수를 나타내는 것

두 네트워크에 하나의 호스트 연결 가능 (그것이 router, ip주소 두개 할당)

#CIDR 예시
ip -> 192.168.4.5/12
이걸 2진수 표현 하면
->  0011110.1010101.100101010.11111 라면 왼쪽 12번째자리까지가 네트워크 주소 그 이후 host

네트쿼크는 prefix suffix type of address purpose로 된 사진
all 0s는 예약어같은 것이다. ()



# 이제 router의 첫번째 기능 포워딩으로 고
지금 ip내용을 알려준 것

router 는 포워딩 테이블을 보고 어떤 경로로 가야지 최적으로 갈 수 있을지 설명
포워딩 테이블이 구성된다 세개 destination/mask/next hop

destination -> 네트워크 주소(host가 전부 0인게)
*ip주소의 network주소?
ip주소가  10.100.38.27/8이면 ip주소가 속한 network주소는 10.0.0.0이다.
사람 찾을 때 동을 먼저 찾지. network 는 살고 있는 공간 ip주소는 실제 찾아가는 애*

router는 동만 찾기 때문에 forwarding table에 destination은 네트워크 주소만 잇는 것이다.
mask있는 이유는 desination주소가 똑같을 수가 있어 어디서 부터 어디까지가 host주소고 network주소인지 알아야할 것 아냐

- mask란?
ip주소 들어왔을 때 패킷에서 destination 으로 보내기 위한 마스크이다.
mask씌워서 destination이랑 일치해 그럼 next hop으로 보낸다.
근데 deliver direct를 통해 바로 direct로 갈 수도 잇다


#NAT(Network Address transmission)
ip주소 부족 현상 해결 위해서 nat만들
공유기 쓴느 거임
- 하나의 호스트를 씀
- 공인 ip와 내부 ip분리
- 내부에서는 내부 ip쓰고 외부로 통할 때는 패킷 나가는 순간 변환 시켜줘서 다른 애들이랑 통신할 수 있따.
- 내부 ip도 결국 컴퓨터 통신 위해서 필요하다.
- block description에서 16 contiguous class b blocks사용 한다. 내부용 아이피 사용할 때
