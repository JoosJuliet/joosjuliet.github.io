---
layout: post
section-type: post
title: "[백준] 10942번 : 팰린드롬? with python3"
categories: Algorithm
tags: [ 'algorithm', '백준', 'python' ]
comments: true
---
문제:
https://www.acmicpc.net/problem/10942

# top-down solution


``` python
import sys
read = lambda : sys.stdin.readline().strip()
write = lambda x: sys.stdout.write(str(x)+ "\n")

sys.setrecursionlimit(10**8)
d = [[-1 for i in range(2001)] for j in range(2001)]
# d[i+1][j-1]
# i+1부터 j-1까지 펠린드롭인지 아닌지 확인하는 것
def fel (x, y):
    if x == y:
        return 1
        # 길이가 1일 때
    elif x+1 == y:
        # 글자가 2일 때
        if a[x] == a[y]:
            return 1
        else:
            return 0

    if d[x][y] != -1:
        return d[x][y]
        # memoization

    if a[x] != a[y]:
      # x와 y가 같지않으면 바로 0준다.
        d[x][y] = 0
        return d[x][y]
    else:
      # 같다면 이제 그속의 다른 애들도 같나 확인을 하기 위해 recursive돈다
        d[x][y] = fel(x+1, y-1)
        return d[x][y]


read()
a = read().split()
for i in range(int(read())):
  ap, dui = map(int, read().split())
  if fel(ap-1, dui-1) == False:
      write(0)
  else:
      write(1)
```

# bottom-up solution

``` python
import sys
read = lambda : sys.stdin.readline().strip()
write = lambda x: sys.stdout.write(str(x)+ "\n")

a = read()
n = len(a)

dp = [[0 for i in range(n + 1)]for j in range(n + 1)]
result = [0] + [sys.maxsize] * (n)

for i in range(1, n+1):
    dp[i][i] = 1
    # 길이가 1인것
    # i부터 i까지의 것중 palindrome 개수니까

for i in range(1, n):
    if a[i-1] == a[i]:
        dp[i][i+1] = 1
        # 길이가 2인 것

for i in range(2, n):
    for j in range(1, n+1-i):
        if a[j-1] == a[i+j-1] and dp[j+1][i+j-1] == 1:
            dp[j][i+j] = 1
# 다양한 길이일 때를 세는 것이다.
# 길이가 i 부터 j까지 길이가 k인 것
# 수치로 하면 i+j-1이다.
#  i ---- k --- p 임으로 p는 i+j-1이 되기 때문이다.

for i in range(1, n+1):
    result[i] = min(result[i], result[i-1] + 1)
    for j in range(i+1, n+1):
        if dp[i][j] != 0:
            result[j] = min(result[j], result[i-1] + 1)

print(result[n])
```
# solution 2

``` python
import sys
read = lambda : sys.stdin.readline().strip()
write = lambda x: sys.stdout.write(str(x)+ "\n")

sys.setrecursionlimit(10**8)
save = [[-1 for i in range(2001)] for j in range(2001)]

def fel (a,b):
    if save[a][b] != -1:
        return save[a][b]
    elif a >= b:
        return 1
    elif seq[a] != seq[b]:
        save[a][b] = 0
        return 0
    else:
        save[a][b] = fel(a+1, b-1)
        return save[a][b]

read()
seq = read().split()
for i in range(int(read())):
  ap, dui = map(int, read().split())
  write(fel(ap-1, dui-1))

```
